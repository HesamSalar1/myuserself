import json
import asyncio
import sys
sys.stdout.reconfigure(encoding='utf-8')

from pyrogram import Client, filters
# ... Ø¨Ù‚ÛŒÙ‡ Ú©Ø¯

from pyrogram import Client, filters
from pyrogram.types import Message
from random import choice

api_id = 15508294  # Ø§Ø² my.telegram.org Ø¨Ú¯ÛŒØ±
api_hash = "778e5cd56ffcf22c2d62aa963ce85a0c"

admin_id = 7850529246  # Ø¢ÛŒâ€ŒØ¯ÛŒ Ø®ÙˆØ¯Øª

app = Client("my_bot", api_id, api_hash)

# Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø¯ÛŒØªØ§ Ø§Ø² ÙØ§ÛŒÙ„
def load_data():
    try:
        with open("data.json", "r") as f:
            return json.load(f)
    except:
        return {"friends": [], "enemies": [], "friend_words": [], "enemy_words": []}

# Ø°Ø®ÛŒØ±Ù‡ Ø¯ÛŒØªØ§ Ø¯Ø± ÙØ§ÛŒÙ„
def save_data():
    with open("data.json", "w") as f:
        json.dump(data, f, indent=2)

# Ø¯ÛŒØªØ§
data = load_data()

# Ø¯Ø³ØªÙˆØ±Ø§Øª Ø§Ø¯Ù…ÛŒÙ† Ø¨Ø±Ø§ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª Ù„ÛŒØ³Øªâ€ŒÙ‡Ø§ Ùˆ Ú©Ù„Ù…Ø§Øª
@app.on_message(filters.command("setfriend") & filters.user(admin_id) & filters.reply)
async def set_friend(client, message: Message):
    user_id = message.reply_to_message.from_user.id
    if user_id not in data["friends"]:
        data["friends"].append(user_id)
        save_data()
        await message.reply("âœ… Ø¨Ù‡ Ù„ÛŒØ³Øª Ø¯ÙˆØ³ØªØ§Ù† Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯.")
    else:
        await message.reply("âš ï¸ Ù‚Ø¨Ù„Ø§Ù‹ Ø¯Ø± Ù„ÛŒØ³Øª Ø¯ÙˆØ³ØªØ§Ù† Ù‡Ø³Øª.")

@app.on_message(filters.command("setenemy") & filters.user(admin_id) & filters.reply)
async def set_enemy(client, message: Message):
    user_id = message.reply_to_message.from_user.id
    if user_id not in data["enemies"]:
        data["enemies"].append(user_id)
        save_data()
        await message.reply("âŒ Ø¨Ù‡ Ù„ÛŒØ³Øª Ø¯Ø´Ù…Ù†Ø§Ù† Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯.")
    else:
        await message.reply("âš ï¸ Ù‚Ø¨Ù„Ø§Ù‹ Ø¯Ø± Ù„ÛŒØ³Øª Ø¯Ø´Ù…Ù†Ø§Ù† Ù‡Ø³Øª.")

@app.on_message(filters.command("addword") & filters.user(admin_id))
async def add_word(client, message: Message):
    if len(message.command) < 3:
        await message.reply("âš ï¸ Ø§Ø³ØªÙØ§Ø¯Ù‡: /addword friend|enemy Ú©Ù„Ù…Ù‡â€Œ")
        return
    target, word = message.command[1], " ".join(message.command[2:])
    if target == "friend":
        data["friend_words"].append(word)
        await message.reply("âœ… Ú©Ù„Ù…Ù‡ Ø¨Ø±Ø§ÛŒ Ø¯ÙˆØ³Øª Ø«Ø¨Øª Ø´Ø¯.")
    elif target == "enemy":
        data["enemy_words"].append(word)
        await message.reply("âœ… Ú©Ù„Ù…Ù‡ Ø¨Ø±Ø§ÛŒ Ø¯Ø´Ù…Ù† Ø«Ø¨Øª Ø´Ø¯.")
    else:
        await message.reply("âš ï¸ Ù†ÙˆØ¹ Ø¨Ø§ÛŒØ¯ friend ÛŒØ§ enemy Ø¨Ø§Ø´Ù‡.")
    save_data()

@app.on_message(filters.command("broadcast") & filters.user(admin_id))
async def broadcast(client, message: Message):
    if len(message.command) < 2:
        await message.reply("ğŸ“¢ Ù„Ø·ÙØ§Ù‹ Ù¾ÛŒØ§Ù… Ø±Ùˆ ÙˆØ§Ø±Ø¯ Ú©Ù†.")
        return
    text = " ".join(message.command[1:])
    all_users = set(data["friends"] + data["enemies"])
    success, fail = 0, 0
    for uid in all_users:
        try:
            await client.send_message(uid, text)
            success += 1
            await asyncio.sleep(0.1)
        except:
            fail += 1
    await message.reply(f"ğŸ“¤ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯. Ù…ÙˆÙÙ‚: {success}, Ù†Ø§Ù…ÙˆÙÙ‚: {fail}")

@app.on_message(filters.private)
async def auto_reply(client, message: Message):
    uid = message.from_user.id
    if uid in data["friends"] and data["friend_words"]:
        await message.reply(choice(data["friend_words"]))
    elif uid in data["enemies"] and data["enemy_words"]:
        await message.reply(choice(data["enemy_words"]))

# Ø§Ø¬Ø±Ø§ÛŒ Ø¨Ø§Øª
print("Ø±Ø¨Ø§Øª Ø±ÙˆØ´Ù† Ø´Ø¯.")
app.run()